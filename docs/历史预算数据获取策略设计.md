# 历史预算数据获取策略设计

## 问题分析

### 现有预算系统的局限性

通过分析现有代码，发现预算管理系统存在以下问题：

```javascript
// 当前预算数据结构（cloudfunctions/manageBudget/index.js）
const budgetData = {
  categoryId: 'food',
  categoryName: '餐饮',
  amount: 1500,
  period: 'monthly', // 只有周期类型，没有具体时间
  type: 'expense',
  spent: 0,
  createdAt: new Date(),
  updatedAt: new Date()
  // 缺少: year, month 等时间维度字段
}
```

**核心问题：**
1. ❌ **缺少时间维度**：预算数据没有绑定具体的年月
2. ❌ **无法区分历史预算**：无法获取特定月份的历史预算设置
3. ❌ **数据覆盖问题**：修改预算会覆盖历史数据，无法追溯

## 解决方案设计

### 方案一：预算数据结构重构（推荐）

#### 1.1 新的预算数据结构
```javascript
// 重构后的预算数据结构
const budgetDataV2 = {
  id: 'budget_expense_food_2025_09',
  categoryId: 'food',
  categoryName: '餐饮',
  amount: 1500,
  type: 'expense',
  year: 2025,           // 新增：年份
  month: 9,             // 新增：月份
  period: 'monthly',    // 保留：周期类型
  status: 'active',     // 新增：状态（active/archived/template）
  isTemplate: false,    // 新增：是否为模板
  templateId: null,     // 新增：模板ID（用于复制预算）
  spent: 0,             // 实际支出（实时计算）
  createdAt: new Date(),
  updatedAt: new Date(),
  createdBy: 'user_123' // 新增：创建者
}
```

#### 1.2 预算模板机制
```javascript
// 预算模板数据结构
const budgetTemplate = {
  id: 'template_expense_food',
  categoryId: 'food',
  categoryName: '餐饮',
  amount: 1500,
  type: 'expense',
  period: 'monthly',
  isTemplate: true,
  status: 'active',
  createdAt: new Date(),
  updatedAt: new Date()
}
```

### 方案二：历史数据获取策略

#### 2.1 数据获取优先级
```javascript
async function getHistoricalBudgetData(year, month, categoryId, type) {
  // 优先级1: 查找该月份的具体预算设置
  const specificBudget = await getBudgetByMonth(year, month, categoryId, type);
  if (specificBudget) {
    return specificBudget;
  }
  
  // 优先级2: 查找最近的预算模板
  const template = await getBudgetTemplate(categoryId, type);
  if (template) {
    return {
      ...template,
      year,
      month,
      isFromTemplate: true,
      originalTemplateId: template.id
    };
  }
  
  // 优先级3: 基于历史实际支出自动生成预算
  const historicalAverage = await calculateHistoricalAverage(categoryId, type, year, month);
  if (historicalAverage > 0) {
    return {
      categoryId,
      categoryName: await getCategoryName(categoryId),
      amount: Math.round(historicalAverage * 1.1), // 历史平均值 + 10%
      type,
      year,
      month,
      isAutoGenerated: true,
      generationMethod: 'historical_average'
    };
  }
  
  // 优先级4: 返回空预算（无历史数据）
  return null;
}
```

#### 2.2 历史数据填充规则

##### 规则1：基于历史实际支出填充
```javascript
async function fillBudgetFromHistoricalSpending(categoryId, type, targetYear, targetMonth) {
  // 获取过去6个月的平均支出
  const historicalData = await getHistoricalSpending(categoryId, type, 6);
  
  if (historicalData.length === 0) {
    return null;
  }
  
  // 计算加权平均（近期权重更高）
  const weightedAverage = calculateWeightedAverage(historicalData);
  
  // 考虑季节性因素
  const seasonalFactor = getSeasonalFactor(categoryId, targetMonth);
  
  // 生成预算建议
  const suggestedBudget = Math.round(weightedAverage * seasonalFactor);
  
  return {
    categoryId,
    amount: suggestedBudget,
    type,
    year: targetYear,
    month: targetMonth,
    isAutoGenerated: true,
    generationMethod: 'weighted_historical_average',
    confidence: calculateConfidence(historicalData),
    sourceData: {
      historicalMonths: historicalData.length,
      averageAmount: weightedAverage,
      seasonalFactor
    }
  };
}
```

##### 规则2：基于同类分类填充
```javascript
async function fillBudgetFromSimilarCategories(categoryId, type, targetYear, targetMonth) {
  // 获取同类型分类的预算设置
  const similarCategories = await getSimilarCategories(categoryId, type);
  
  if (similarCategories.length === 0) {
    return null;
  }
  
  // 计算同类分类的平均预算
  const averageBudget = similarCategories.reduce((sum, cat) => sum + cat.amount, 0) / similarCategories.length;
  
  return {
    categoryId,
    amount: Math.round(averageBudget),
    type,
    year: targetYear,
    month: targetMonth,
    isAutoGenerated: true,
    generationMethod: 'similar_categories_average',
    sourceData: {
      similarCategoriesCount: similarCategories.length,
      averageAmount: averageBudget
    }
  };
}
```

##### 规则3：基于收入比例填充
```javascript
async function fillBudgetFromIncomeRatio(categoryId, type, targetYear, targetMonth) {
  if (type !== 'expense') {
    return null;
  }
  
  // 获取该月份的总收入
  const monthlyIncome = await getMonthlyIncome(targetYear, targetMonth);
  if (monthlyIncome <= 0) {
    return null;
  }
  
  // 根据分类获取推荐比例
  const recommendedRatio = getCategoryRecommendedRatio(categoryId);
  
  const suggestedBudget = Math.round(monthlyIncome * recommendedRatio);
  
  return {
    categoryId,
    amount: suggestedBudget,
    type,
    year: targetYear,
    month: targetMonth,
    isAutoGenerated: true,
    generationMethod: 'income_ratio',
    sourceData: {
      monthlyIncome,
      recommendedRatio,
      ratioPercentage: Math.round(recommendedRatio * 100)
    }
  };
}
```

### 方案三：数据迁移策略

#### 3.1 现有数据迁移
```javascript
async function migrateLegacyBudgetData() {
  console.log('开始迁移历史预算数据...');
  
  // 1. 获取所有现有预算数据
  const legacyBudgets = await db.collection('budgets').get();
  
  // 2. 为每个预算创建模板
  const templates = legacyBudgets.data.map(budget => ({
    ...budget,
    id: `template_${budget.type}_${budget.categoryId}`,
    isTemplate: true,
    status: 'active',
    migratedFrom: budget._id
  }));
  
  // 3. 保存模板到新集合
  await db.collection('budget_templates').add(templates);
  
  // 4. 为当前月份创建具体预算
  const currentYear = new Date().getFullYear();
  const currentMonth = new Date().getMonth() + 1;
  
  const currentBudgets = legacyBudgets.data.map(budget => ({
    ...budget,
    id: `budget_${budget.type}_${budget.categoryId}_${currentYear}_${currentMonth}`,
    year: currentYear,
    month: currentMonth,
    templateId: `template_${budget.type}_${budget.categoryId}`,
    isTemplate: false,
    status: 'active'
  }));
  
  // 5. 保存当前月份预算
  await db.collection('budgets_v2').add(currentBudgets);
  
  console.log('预算数据迁移完成');
}
```

#### 3.2 渐进式迁移
```javascript
// 兼容性处理：同时支持新旧数据结构
async function getBudgetDataCompatible(year, month, categoryId, type) {
  // 优先使用新数据结构
  const newBudget = await getBudgetV2(year, month, categoryId, type);
  if (newBudget) {
    return newBudget;
  }
  
  // 回退到旧数据结构
  const legacyBudget = await getLegacyBudget(categoryId, type);
  if (legacyBudget) {
    // 转换为新格式
    return {
      ...legacyBudget,
      year,
      month,
      isLegacy: true
    };
  }
  
  return null;
}
```

## 具体实现方案

### 4.1 按年统计的历史预算获取

```javascript
async function getYearlyBudgetComparison(year) {
  const result = {
    year,
    months: [],
    categories: {}
  };
  
  // 获取该年度每个月的预算数据
  for (let month = 1; month <= 12; month++) {
    const monthlyBudgets = await getMonthlyBudgets(year, month);
    
    result.months.push({
      month,
      budgets: monthlyBudgets,
      totalBudgeted: monthlyBudgets.reduce((sum, b) => sum + b.amount, 0),
      totalActual: await getMonthlyActualSpending(year, month)
    });
    
    // 按分类汇总
    monthlyBudgets.forEach(budget => {
      if (!result.categories[budget.categoryId]) {
        result.categories[budget.categoryId] = {
          categoryId: budget.categoryId,
          categoryName: budget.categoryName,
          type: budget.type,
          monthlyData: []
        };
      }
      
      result.categories[budget.categoryId].monthlyData.push({
        month,
        budgeted: budget.amount,
        actual: await getCategoryMonthlySpending(year, month, budget.categoryId, budget.type),
        isAutoGenerated: budget.isAutoGenerated || false
      });
    });
  }
  
  return result;
}
```

### 4.2 自定义周期的历史预算获取

```javascript
async function getCustomPeriodBudgetComparison(startDate, endDate) {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const result = {
    period: `${startDate} 至 ${endDate}`,
    months: [],
    totalBudgeted: 0,
    totalActual: 0
  };
  
  // 遍历周期内的每个月
  let current = new Date(start.getFullYear(), start.getMonth(), 1);
  while (current <= end) {
    const year = current.getFullYear();
    const month = current.getMonth() + 1;
    
    // 计算该月在周期内的天数比例
    const monthStart = new Date(year, month - 1, 1);
    const monthEnd = new Date(year, month, 0);
    const periodStart = start > monthStart ? start : monthStart;
    const periodEnd = end < monthEnd ? end : monthEnd;
    const daysInPeriod = Math.ceil((periodEnd - periodStart) / (1000 * 60 * 60 * 24)) + 1;
    const totalDaysInMonth = monthEnd.getDate();
    const dayRatio = daysInPeriod / totalDaysInMonth;
    
    // 获取该月预算并按比例计算
    const monthlyBudgets = await getMonthlyBudgets(year, month);
    const adjustedBudgets = monthlyBudgets.map(budget => ({
      ...budget,
      amount: Math.round(budget.amount * dayRatio),
      originalAmount: budget.amount,
      dayRatio
    }));
    
    const monthlyBudgeted = adjustedBudgets.reduce((sum, b) => sum + b.amount, 0);
    const monthlyActual = await getPeriodActualSpending(periodStart, periodEnd);
    
    result.months.push({
      year,
      month,
      daysInPeriod,
      totalDaysInMonth,
      dayRatio,
      budgets: adjustedBudgets,
      budgeted: monthlyBudgeted,
      actual: monthlyActual
    });
    
    result.totalBudgeted += monthlyBudgeted;
    result.totalActual += monthlyActual;
    
    // 移动到下个月
    current.setMonth(current.getMonth() + 1);
  }
  
  return result;
}
```

## 用户界面提示

### 5.1 数据来源标识
```javascript
// 在界面上显示数据来源
const budgetSourceLabels = {
  'specific': '✅ 已设置',
  'template': '📋 模板',
  'historical_average': '📊 历史平均',
  'similar_categories': '🔄 同类参考',
  'income_ratio': '💰 收入比例',
  'auto_generated': '🤖 自动生成'
};

// 界面展示示例
function renderBudgetItem(budget) {
  const sourceLabel = budgetSourceLabels[budget.generationMethod] || '❓ 未知';
  
  return `
    <view class="budget-item">
      <view class="category-name">${budget.categoryName}</view>
      <view class="budget-amount">预算: ¥${budget.amount}</view>
      <view class="budget-source">${sourceLabel}</view>
      ${budget.isAutoGenerated ? '<view class="auto-tip">系统自动生成</view>' : ''}
    </view>
  `;
}
```

### 5.2 预算建议功能
```javascript
// 为缺失预算的分类提供建议
async function generateBudgetSuggestions(year, month) {
  const categories = await getAllCategories();
  const suggestions = [];
  
  for (const category of categories) {
    const existingBudget = await getBudgetByMonth(year, month, category.id, category.type);
    
    if (!existingBudget) {
      const suggestion = await generateBudgetSuggestion(category.id, category.type, year, month);
      if (suggestion) {
        suggestions.push(suggestion);
      }
    }
  }
  
  return suggestions;
}
```

## 总结

通过以上设计方案，我们可以有效解决历史预算数据获取的问题：

1. **数据结构重构**：为预算数据增加时间维度，支持历史数据追溯
2. **智能填充策略**：基于历史支出、同类分类、收入比例等多种方式自动生成预算
3. **渐进式迁移**：保证现有功能不受影响，平滑过渡到新数据结构
4. **用户体验优化**：清晰标识数据来源，提供预算建议功能

这样既解决了历史数据缺失的问题，又为用户提供了智能的预算管理体验。