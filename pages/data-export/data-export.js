// pages/data-export/data-export.js
const exportService = require('../../services/export')
const dataManager = require('../../services/dataManager')
const { showToast } = require('../../utils/uiUtil')
const { formatDate, formatCurrency } = require('../../utils/formatter')

Page({
  data: {
    // ÂØºÂá∫Á±ªÂûã
    exportTypes: [
      {
        id: 'transactions',
        name: 'ÊîØÂá∫ËÆ∞ÂΩï',
        description: 'ÂØºÂá∫ÊåáÂÆöÊó∂Èó¥ËåÉÂõ¥ÁöÑÊî∂ÊîØËÆ∞ÂΩï',
        icon: 'üìä'
      },
      {
        id: 'assets',
        name: 'ËµÑ‰∫ßÊï∞ÊçÆ',
        description: 'ÂØºÂá∫ÂΩìÂâçÊâÄÊúâË¥¶Êà∑ËµÑ‰∫ß‰ø°ÊÅØ',
        icon: 'üí∞'
      },
      {
        id: 'report',
        name: 'Ë¥¢Âä°Êä•Ë°®',
        description: 'ÂØºÂá∫Ë¥¢Âä°ÂàÜÊûêÊä•Ë°®',
        icon: 'üìà'
      }
    ],
    
    // ÂΩìÂâçÈÄâÊã©ÁöÑÂØºÂá∫Á±ªÂûã
    selectedType: 'transactions',
    
    // ÂØºÂá∫Ê†ºÂºè
    formats: [
      { id: 'excel', name: 'Excel', description: '.xlsxÊ†ºÂºèÔºåÈÄÇÂêàÊï∞ÊçÆÂàÜÊûê' },
      { id: 'pdf', name: 'PDF', description: '.pdfÊ†ºÂºèÔºåÈÄÇÂêàÊâìÂç∞ÂíåÂàÜ‰∫´' }
    ],
    selectedFormat: 'excel',
    
    // Êó∂Èó¥ËåÉÂõ¥
    dateRange: {
      startDate: '',
      endDate: '',
      presets: [
        { id: 'thisMonth', name: 'Êú¨Êúà', startDate: '', endDate: '' },
        { id: 'lastMonth', name: '‰∏äÊúà', startDate: '', endDate: '' },
        { id: 'thisYear', name: '‰ªäÂπ¥', startDate: '', endDate: '' },
        { id: 'lastYear', name: 'ÂéªÂπ¥', startDate: '', endDate: '' }
      ]
    },
    
    // Á≠õÈÄâÊù°‰ª∂
    filters: {
      categories: [],
      accounts: [],
      includeHistory: true
    },
    
    // ÂèØÈÄâÁöÑÂàÜÁ±ªÂíåË¥¶Êà∑
    availableCategories: [],
    availableAccounts: [],
    
    // ÂØºÂá∫ÂéÜÂè≤
    exportHistory: [],
    
    // UIÁä∂ÊÄÅ
    loading: false,
    showFilters: false,
    showHistory: false
  },

  onLoad() {
    this.initPage()
  },

  onShow() {
    this.refreshData()
  },

  // ÂàùÂßãÂåñÈ°µÈù¢
  async initPage() {
    try {
      // ÂàùÂßãÂåñÊó∂Èó¥ËåÉÂõ¥È¢ÑËÆæ
      this.initDatePresets()
      
      // Âä†ËΩΩÂèØÈÄâÁöÑÂàÜÁ±ªÂíåË¥¶Êà∑
      await this.loadFilterOptions()
      
      // Âä†ËΩΩÂØºÂá∫ÂéÜÂè≤
      this.loadExportHistory()
      
    } catch (error) {
      console.error('ÂàùÂßãÂåñÈ°µÈù¢Â§±Ë¥•:', error)
      showToast('ÂàùÂßãÂåñÂ§±Ë¥•', 'error')
    }
  },

  // Âà∑Êñ∞Êï∞ÊçÆ
  async refreshData() {
    try {
      await this.loadFilterOptions()
      this.loadExportHistory()
    } catch (error) {
      console.error('Âà∑Êñ∞Êï∞ÊçÆÂ§±Ë¥•:', error)
    }
  },

  // ÂàùÂßãÂåñÊó∂Èó¥ËåÉÂõ¥È¢ÑËÆæ
  initDatePresets() {
    const now = new Date()
    const currentYear = now.getFullYear()
    const currentMonth = now.getMonth()
    
    // Êú¨Êúà
    const thisMonthStart = new Date(currentYear, currentMonth, 1)
    const thisMonthEnd = new Date(currentYear, currentMonth + 1, 0)
    
    // ‰∏äÊúà
    const lastMonthStart = new Date(currentYear, currentMonth - 1, 1)
    const lastMonthEnd = new Date(currentYear, currentMonth, 0)
    
    // ‰ªäÂπ¥
    const thisYearStart = new Date(currentYear, 0, 1)
    const thisYearEnd = new Date(currentYear, 11, 31)
    
    // ÂéªÂπ¥
    const lastYearStart = new Date(currentYear - 1, 0, 1)
    const lastYearEnd = new Date(currentYear - 1, 11, 31)
    
    const presets = [
      {
        id: 'thisMonth',
        name: 'Êú¨Êúà',
        startDate: formatDate(thisMonthStart, 'YYYY-MM-DD'),
        endDate: formatDate(thisMonthEnd, 'YYYY-MM-DD')
      },
      {
        id: 'lastMonth',
        name: '‰∏äÊúà',
        startDate: formatDate(lastMonthStart, 'YYYY-MM-DD'),
        endDate: formatDate(lastMonthEnd, 'YYYY-MM-DD')
      },
      {
        id: 'thisYear',
        name: '‰ªäÂπ¥',
        startDate: formatDate(thisYearStart, 'YYYY-MM-DD'),
        endDate: formatDate(thisYearEnd, 'YYYY-MM-DD')
      },
      {
        id: 'lastYear',
        name: 'ÂéªÂπ¥',
        startDate: formatDate(lastYearStart, 'YYYY-MM-DD'),
        endDate: formatDate(lastYearEnd, 'YYYY-MM-DD')
      }
    ]
    
    // ÈªòËÆ§ÈÄâÊã©Êú¨Êúà
    this.setData({
      'dateRange.presets': presets,
      'dateRange.startDate': presets[0].startDate,
      'dateRange.endDate': presets[0].endDate
    })
  },

  // Âä†ËΩΩÁ≠õÈÄâÈÄâÈ°π
  async loadFilterOptions() {
    try {
      const categories = dataManager.getAllCategories()
      const accounts = dataManager.getAllAccounts()
      
      this.setData({
        availableCategories: categories,
        availableAccounts: accounts
      })
    } catch (error) {
      console.error('Âä†ËΩΩÁ≠õÈÄâÈÄâÈ°πÂ§±Ë¥•:', error)
    }
  },

  // Âä†ËΩΩÂØºÂá∫ÂéÜÂè≤
  loadExportHistory() {
    const history = exportService.getExportHistory()
    this.setData({
      exportHistory: history
    })
  },

  // ÈÄâÊã©ÂØºÂá∫Á±ªÂûã
  onTypeSelect(e) {
    const typeId = e.currentTarget.dataset.id
    this.setData({
      selectedType: typeId
    })
  },

  // ÈÄâÊã©ÂØºÂá∫Ê†ºÂºè
  onFormatSelect(e) {
    const formatId = e.currentTarget.dataset.id
    this.setData({
      selectedFormat: formatId
    })
  },

  // ÈÄâÊã©Êó∂Èó¥È¢ÑËÆæ
  onDatePresetSelect(e) {
    const preset = e.currentTarget.dataset.preset
    this.setData({
      'dateRange.startDate': preset.startDate,
      'dateRange.endDate': preset.endDate
    })
  },

  // ÂºÄÂßãÊó•ÊúüÂèòÊõ¥
  onStartDateChange(e) {
    this.setData({
      'dateRange.startDate': e.detail.value
    })
  },

  // ÁªìÊùüÊó•ÊúüÂèòÊõ¥
  onEndDateChange(e) {
    this.setData({
      'dateRange.endDate': e.detail.value
    })
  },

  // ÂàáÊç¢Á≠õÈÄâÈù¢Êùø
  toggleFilters() {
    this.setData({
      showFilters: !this.data.showFilters
    })
  },

  // ÂàÜÁ±ªÈÄâÊã©ÂèòÊõ¥
  onCategoryChange(e) {
    const categoryId = e.currentTarget.dataset.id
    const categories = [...this.data.filters.categories]
    const index = categories.indexOf(categoryId)
    
    if (index > -1) {
      categories.splice(index, 1)
    } else {
      categories.push(categoryId)
    }
    
    this.setData({
      'filters.categories': categories
    })
  },

  // Ë¥¶Êà∑ÈÄâÊã©ÂèòÊõ¥
  onAccountChange(e) {
    const accountId = e.currentTarget.dataset.id
    const accounts = [...this.data.filters.accounts]
    const index = accounts.indexOf(accountId)
    
    if (index > -1) {
      accounts.splice(index, 1)
    } else {
      accounts.push(accountId)
    }
    
    this.setData({
      'filters.accounts': accounts
    })
  },

  // ÂåÖÂê´ÂéÜÂè≤ËÆ∞ÂΩïÂàáÊç¢
  onIncludeHistoryChange(e) {
    this.setData({
      'filters.includeHistory': e.detail.value
    })
  },

  // Ê∏ÖÈô§Á≠õÈÄâÊù°‰ª∂
  clearFilters() {
    this.setData({
      'filters.categories': [],
      'filters.accounts': [],
      'filters.includeHistory': true
    })
  },

  // ÂºÄÂßãÂØºÂá∫
  async startExport() {
    if (this.data.loading) return
    
    try {
      this.setData({ loading: true })
      
      // È™åËØÅÂèÇÊï∞
      const validation = this.validateExportParams()
      if (!validation.valid) {
        showToast(validation.message, 'error')
        return
      }
      
      // ÊûÑÂª∫ÂØºÂá∫ÈÄâÈ°π
      const options = this.buildExportOptions()
      
      // ÊâßË°åÂØºÂá∫ - ‰ΩøÁî®ÁÆÄÂåñÁöÑÂØºÂá∫ÈÄªËæë
      let result
      switch (this.data.selectedType) {
        case 'transactions':
          result = await this.exportTransactionsData(options)
          break
        case 'assets':
          result = await this.exportAssetsData(options)
          break
        case 'report':
          result = await this.exportReportData(options)
          break
        default:
          throw new Error('‰∏çÊîØÊåÅÁöÑÂØºÂá∫Á±ªÂûã')
      }
      
      // Â§ÑÁêÜÂØºÂá∫ÁªìÊûú
      await this.handleExportResult(result)
      
      // Âà∑Êñ∞ÂØºÂá∫ÂéÜÂè≤
      this.loadExportHistory()
      
      showToast('ÂØºÂá∫ÊàêÂäü', 'success')
      
    } catch (error) {
      console.error('ÂØºÂá∫Â§±Ë¥•:', error)
      showToast(error.message || 'ÂØºÂá∫Â§±Ë¥•', 'error')
    } finally {
      this.setData({ loading: false })
    }
  },

  // ÂØºÂá∫‰∫§ÊòìÊï∞ÊçÆ
  async exportTransactionsData(options) {
    const transactions = wx.getStorageSync('transactions') || []
    
    // Á≠õÈÄâÊï∞ÊçÆ
    let filteredData = transactions.filter(t => {
      const transactionDate = new Date(t.date)
      const startDate = new Date(options.startDate)
      const endDate = new Date(options.endDate)
      
      return transactionDate >= startDate && transactionDate <= endDate
    })
    
    // Â∫îÁî®ÂàÜÁ±ªÁ≠õÈÄâ
    if (options.categories && options.categories.length > 0) {
      filteredData = filteredData.filter(t => options.categories.includes(t.categoryId))
    }
    
    // Â∫îÁî®Ë¥¶Êà∑Á≠õÈÄâ
    if (options.accounts && options.accounts.length > 0) {
      filteredData = filteredData.filter(t => options.accounts.includes(t.accountId))
    }
    
    // ÁîüÊàêÂØºÂá∫ÂÜÖÂÆπ
    const content = this.generateExportContent(filteredData, options.format)
    const fileName = `‰∫§ÊòìËÆ∞ÂΩï_${options.startDate}_${options.endDate}.${options.format === 'excel' ? 'csv' : 'txt'}`
    
    return {
      fileName,
      content,
      fileSize: content.length,
      recordCount: filteredData.length
    }
  },

  // ÂØºÂá∫ËµÑ‰∫ßÊï∞ÊçÆ
  async exportAssetsData(options) {
    const accounts = wx.getStorageSync('accounts') || []
    const transactions = wx.getStorageSync('transactions') || []
    
    // ËÆ°ÁÆóÊØè‰∏™Ë¥¶Êà∑ÁöÑ‰ΩôÈ¢ù
    const accountsWithBalance = accounts.map(account => {
      const accountTransactions = transactions.filter(t => t.accountId === account.id)
      const balance = accountTransactions.reduce((sum, t) => {
        return sum + (t.type === 'income' ? t.amount : -t.amount)
      }, account.initialBalance || 0)
      
      return {
        ...account,
        balance,
        transactionCount: accountTransactions.length
      }
    })
    
    const content = this.generateAssetsContent(accountsWithBalance, options.format)
    const fileName = `ËµÑ‰∫ßÊï∞ÊçÆ_${new Date().toISOString().split('T')[0]}.${options.format === 'excel' ? 'csv' : 'txt'}`
    
    return {
      fileName,
      content,
      fileSize: content.length,
      recordCount: accountsWithBalance.length
    }
  },

  // ÂØºÂá∫Êä•Ë°®Êï∞ÊçÆ
  async exportReportData(options) {
    const transactions = wx.getStorageSync('transactions') || []
    
    // Á≠õÈÄâÊó∂Èó¥ËåÉÂõ¥ÂÜÖÁöÑÊï∞ÊçÆ
    const filteredData = transactions.filter(t => {
      const transactionDate = new Date(t.date)
      const startDate = new Date(options.startDate)
      const endDate = new Date(options.endDate)
      
      return transactionDate >= startDate && transactionDate <= endDate
    })
    
    // ÁîüÊàêÁªüËÆ°Êä•Ë°®
    const report = this.generateReportData(filteredData)
    const content = this.generateReportContent(report, options.format)
    const fileName = `Ë¥¢Âä°Êä•Ë°®_${options.startDate}_${options.endDate}.${options.format === 'excel' ? 'csv' : 'txt'}`
    
    return {
      fileName,
      content,
      fileSize: content.length,
      recordCount: filteredData.length
    }
  },

  // ÁîüÊàêÂØºÂá∫ÂÜÖÂÆπ
  generateExportContent(data, format) {
    if (format === 'excel') {
      // CSVÊ†ºÂºè
      let csv = 'Êó•Êúü,Á±ªÂûã,ÂàÜÁ±ª,Ë¥¶Êà∑,ÈáëÈ¢ù,ÊèèËø∞
'
      data.forEach(item => {
        csv += `${item.date},${item.type === 'income' ? 'Êî∂ÂÖ•' : 'ÊîØÂá∫'},${item.category},${item.account},${(item.amount / 100).toFixed(2)},${item.description || ''}
`
      })
      return csv
    } else {
      // ÊñáÊú¨Ê†ºÂºè
      let text = '‰∫§ÊòìËÆ∞ÂΩïÂØºÂá∫
'
      text += '================

'
      data.forEach(item => {
        text += `Êó•Êúü: ${item.date}
`
        text += `Á±ªÂûã: ${item.type === 'income' ? 'Êî∂ÂÖ•' : 'ÊîØÂá∫'}
`
        text += `ÂàÜÁ±ª: ${item.category}
`
        text += `Ë¥¶Êà∑: ${item.account}
`
        text += `ÈáëÈ¢ù: ¬•${(item.amount / 100).toFixed(2)}
`
        text += `ÊèèËø∞: ${item.description || 'Êó†'}
`
        text += '----------------
'
      })
      return text
    }
  },

  // ÁîüÊàêËµÑ‰∫ßÂÜÖÂÆπ
  generateAssetsContent(accounts, format) {
    if (format === 'excel') {
      let csv = 'Ë¥¶Êà∑ÂêçÁß∞,Ë¥¶Êà∑Á±ªÂûã,ÂΩìÂâç‰ΩôÈ¢ù,‰∫§ÊòìÁ¨îÊï∞
'
      accounts.forEach(account => {
        csv += `${account.name},${account.type},${(account.balance / 100).toFixed(2)},${account.transactionCount}
`
      })
      return csv
    } else {
      let text = 'ËµÑ‰∫ßÊï∞ÊçÆÂØºÂá∫
'
      text += '================

'
      accounts.forEach(account => {
        text += `Ë¥¶Êà∑: ${account.name}
`
        text += `Á±ªÂûã: ${account.type}
`
        text += `‰ΩôÈ¢ù: ¬•${(account.balance / 100).toFixed(2)}
`
        text += `‰∫§ÊòìÁ¨îÊï∞: ${account.transactionCount}
`
        text += '----------------
'
      })
      return text
    }
  },

  // ÁîüÊàêÊä•Ë°®Êï∞ÊçÆ
  generateReportData(transactions) {
    const income = transactions.filter(t => t.type === 'income')
    const expense = transactions.filter(t => t.type === 'expense')
    
    const totalIncome = income.reduce((sum, t) => sum + t.amount, 0)
    const totalExpense = expense.reduce((sum, t) => sum + t.amount, 0)
    
    // ÊåâÂàÜÁ±ªÁªüËÆ°
    const categoryStats = {}
    transactions.forEach(t => {
      if (!categoryStats[t.category]) {
        categoryStats[t.category] = { income: 0, expense: 0, count: 0 }
      }
      if (t.type === 'income') {
        categoryStats[t.category].income += t.amount
      } else {
        categoryStats[t.category].expense += t.amount
      }
      categoryStats[t.category].count++
    })
    
    return {
      totalIncome,
      totalExpense,
      netIncome: totalIncome - totalExpense,
      transactionCount: transactions.length,
      categoryStats
    }
  },

  // ÁîüÊàêÊä•Ë°®ÂÜÖÂÆπ
  generateReportContent(report, format) {
    if (format === 'excel') {
      let csv = 'È°πÁõÆ,ÈáëÈ¢ù
'
      csv += `ÊÄªÊî∂ÂÖ•,${(report.totalIncome / 100).toFixed(2)}
`
      csv += `ÊÄªÊîØÂá∫,${(report.totalExpense / 100).toFixed(2)}
`
      csv += `ÂáÄÊî∂ÂÖ•,${(report.netIncome / 100).toFixed(2)}
`
      csv += `‰∫§ÊòìÁ¨îÊï∞,${report.transactionCount}

`
      csv += 'ÂàÜÁ±ªÁªüËÆ°
'
      csv += 'ÂàÜÁ±ª,Êî∂ÂÖ•,ÊîØÂá∫,Á¨îÊï∞
'
      Object.entries(report.categoryStats).forEach(([category, stats]) => {
        csv += `${category},${(stats.income / 100).toFixed(2)},${(stats.expense / 100).toFixed(2)},${stats.count}
`
      })
      return csv
    } else {
      let text = 'Ë¥¢Âä°Êä•Ë°®
'
      text += '================

'
      text += `ÊÄªÊî∂ÂÖ•: ¬•${(report.totalIncome / 100).toFixed(2)}
`
      text += `ÊÄªÊîØÂá∫: ¬•${(report.totalExpense / 100).toFixed(2)}
`
      text += `ÂáÄÊî∂ÂÖ•: ¬•${(report.netIncome / 100).toFixed(2)}
`
      text += `‰∫§ÊòìÁ¨îÊï∞: ${report.transactionCount}

`
      text += 'ÂàÜÁ±ªÁªüËÆ°:
'
      text += '----------------
'
      Object.entries(report.categoryStats).forEach(([category, stats]) => {
        text += `${category}:
`
        text += `  Êî∂ÂÖ•: ¬•${(stats.income / 100).toFixed(2)}
`
        text += `  ÊîØÂá∫: ¬•${(stats.expense / 100).toFixed(2)}
`
        text += `  Á¨îÊï∞: ${stats.count}
`
      })
      return text
    }
  },

  // È™åËØÅÂØºÂá∫ÂèÇÊï∞
  validateExportParams() {
    const { selectedType, dateRange } = this.data
    
    // ÂØπ‰∫éÈúÄË¶ÅÊó∂Èó¥ËåÉÂõ¥ÁöÑÂØºÂá∫Á±ªÂûãÔºåÈ™åËØÅÊó∂Èó¥ËåÉÂõ¥
    if (selectedType === 'transactions' || selectedType === 'report') {
      if (!dateRange.startDate || !dateRange.endDate) {
        return { valid: false, message: 'ËØ∑ÈÄâÊã©Êó∂Èó¥ËåÉÂõ¥' }
      }
      
      if (new Date(dateRange.startDate) > new Date(dateRange.endDate)) {
        return { valid: false, message: 'ÂºÄÂßãÊó•Êúü‰∏çËÉΩÊôö‰∫éÁªìÊùüÊó•Êúü' }
      }
    }
    
    return { valid: true }
  },

  // ÊûÑÂª∫ÂØºÂá∫ÈÄâÈ°π
  buildExportOptions() {
    const { selectedFormat, dateRange, filters } = this.data
    
    const options = {
      format: selectedFormat
    }
    
    // Ê∑ªÂä†Êó∂Èó¥ËåÉÂõ¥
    if (dateRange.startDate && dateRange.endDate) {
      options.startDate = dateRange.startDate
      options.endDate = dateRange.endDate
    }
    
    // Ê∑ªÂä†Á≠õÈÄâÊù°‰ª∂
    if (filters.categories.length > 0) {
      options.categories = filters.categories
    }
    
    if (filters.accounts.length > 0) {
      options.accounts = filters.accounts
    }
    
    options.includeHistory = filters.includeHistory
    
    return options
  },

  // Â§ÑÁêÜÂØºÂá∫ÁªìÊûú
  async handleExportResult(result) {
    // ÊòæÁ§∫ÂØºÂá∫ÊàêÂäüÂØπËØùÊ°Ü
    const res = await new Promise(resolve => {
      wx.showModal({
        title: 'ÂØºÂá∫ÊàêÂäü',
        content: `Êñá‰ª∂Ôºö${result.fileName}\nÂ§ßÂ∞èÔºö${this.formatFileSize(result.fileSize)}\n\nÈÄâÊã©Êìç‰ΩúÔºö`,
        confirmText: 'ÂàÜ‰∫´',
        cancelText: '‰øùÂ≠ò',
        success: resolve
      })
    })
    
    if (res.confirm) {
      // ÂàÜ‰∫´Êñá‰ª∂
      await exportService.shareFile(result)
    } else if (res.cancel) {
      // ‰øùÂ≠òÊñá‰ª∂
      await exportService.saveFile(result)
      showToast('Êñá‰ª∂Â∑≤‰øùÂ≠ò', 'success')
    }
  },

  // Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
  formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B'
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB'
  },

  // ÂàáÊç¢ÂéÜÂè≤Èù¢Êùø
  toggleHistory() {
    this.setData({
      showHistory: !this.data.showHistory
    })
  },

  // ÈáçÊñ∞ÂØºÂá∫ÂéÜÂè≤ËÆ∞ÂΩï
  async reExport(e) {
    const record = e.currentTarget.dataset.record
    
    try {
      this.setData({ loading: true })
      
      // Ê†πÊçÆÂéÜÂè≤ËÆ∞ÂΩïÈáçÊñ∞ÊûÑÂª∫ÂØºÂá∫ÈÄâÈ°π
      const options = {
        format: record.format,
        startDate: record.startDate,
        endDate: record.endDate,
        categories: record.categories || [],
        accounts: record.accounts || [],
        includeHistory: record.includeHistory !== false
      }
      
      // ÊâßË°åÂØºÂá∫
      let result
      switch (record.type) {
        case 'transactions':
          result = await exportService.exportTransactions(options)
          break
        case 'assets':
          result = await exportService.exportAssets(options)
          break
        case 'report':
          result = await exportService.exportFinancialReport(options)
          break
        default:
          throw new Error('‰∏çÊîØÊåÅÁöÑÂØºÂá∫Á±ªÂûã')
      }
      
      // Â§ÑÁêÜÂØºÂá∫ÁªìÊûú
      await this.handleExportResult(result)
      
      showToast('ÈáçÊñ∞ÂØºÂá∫ÊàêÂäü', 'success')
      
    } catch (error) {
      console.error('ÈáçÊñ∞ÂØºÂá∫Â§±Ë¥•:', error)
      showToast(error.message || 'ÈáçÊñ∞ÂØºÂá∫Â§±Ë¥•', 'error')
    } finally {
      this.setData({ loading: false })
    }
  },

  // Âà†Èô§ÂØºÂá∫ËÆ∞ÂΩï
  deleteExportRecord(e) {
    const recordId = e.currentTarget.dataset.id
    
    wx.showModal({
      title: 'Âà†Èô§ËÆ∞ÂΩï',
      content: 'Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ÂØºÂá∫ËÆ∞ÂΩïÂêóÔºü',
      success: (res) => {
        if (res.confirm) {
          exportService.deleteExportRecord(recordId)
          this.loadExportHistory()
          showToast('ËÆ∞ÂΩïÂ∑≤Âà†Èô§', 'success')
        }
      }
    })
  },

  // Ê∏ÖÈô§ÊâÄÊúâÂØºÂá∫ÂéÜÂè≤
  clearAllHistory() {
    wx.showModal({
      title: 'Ê∏ÖÈô§ÂéÜÂè≤',
      content: 'Á°ÆÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÂØºÂá∫ÂéÜÂè≤ËÆ∞ÂΩïÂêóÔºü',
      success: (res) => {
        if (res.confirm) {
          exportService.clearExportHistory()
          this.loadExportHistory()
          showToast('ÂéÜÂè≤ËÆ∞ÂΩïÂ∑≤Ê∏ÖÈô§', 'success')
        }
      }
    })
  },

  // Ëé∑ÂèñÂØºÂá∫Á±ªÂûãÊñáÊú¨
  getExportTypeText(type) {
    const typeMap = {
      'transactions': 'ÊîØÂá∫ËÆ∞ÂΩï',
      'assets': 'ËµÑ‰∫ßÊï∞ÊçÆ',
      'report': 'Ë¥¢Âä°Êä•Ë°®'
    }
    return typeMap[type] || type
  },

  // Ëé∑ÂèñÊ†ºÂºèÊñáÊú¨
  getFormatText(format) {
    const formatMap = {
      'excel': 'Excel',
      'pdf': 'PDF'
    }
    return formatMap[format] || format
  }
})